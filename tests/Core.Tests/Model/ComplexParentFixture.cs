using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using AutoFixture.Xunit2;
using FluentAssertions;
using Moq;
using Xunit;

namespace AutoFixture.Extensions.Tests
{
    public class ComplexParentFixture : BaseFixtureSetup<ComplexParent>
    {
        /// <inheritdoc />
        public ComplexParentFixture(IFixture fixture) : base(fixture)
        {
        }

        /// <inheritdoc />
        public ComplexParentFixture(IFixture fixture, ComplexParent item) : base(fixture, item)
        {
        }

        /// <inheritdoc />
        public ComplexParentFixture(
            IFixture fixture,
            Func<FixtureSetupOptions<ComplexParent>, FixtureSetupOptions<ComplexParent>> options) : base(fixture, options)
        {
        }

        #region Properties

        // For unit test comparisons
        internal static readonly StructChild StructChild = new("testHost", 80);

        protected override Func<FixtureSetupOptions<ComplexParent>, FixtureSetupOptions<ComplexParent>> Setups =>
            options => options
                .Setup(_ => _.ComplexChild, new ComplexChildFixture(Fixture) { MyNumber = 777 }.Object)
                .Setup(_ => _.StructChild, StructChild);

        #endregion
    }

    public class ComplexParentFixtureTest
    {
        [Theory, AutoMoqData(false)]
        public Task FixtureSetup_DisableAutoGeneration_ShouldReturnDefault(IFixture fixture)
        {
            // Arrange
            var complexChild = new ComplexChildFixture(fixture).Object;
            var sut = new ComplexParentFixture(fixture);

            // Act
            var i0 = new ComplexParent(complexChild);
            var i1 = sut.Object;
            var i2 = fixture.Create<ComplexParent>();

            // Assert
            // Should not be equivalent to i0, because of the object initialization on sut.
            i1.Should().NotBeNull();
            i1.Should().NotBeSameAs(i0);
            i1.Should().BeEquivalentTo(i0, opt => opt
                .Excluding(_ => _.StructChild) // Struct child is in setup
            );
            i1.Should().BeSameAs(i2);
            i1.SimpleChild.Should().BeNull(); // Default is null
            i1.ComplexChild.Should().BeSameAs(complexChild);
            i1.StructChild.Should().BeEquivalentTo(ComplexParentFixture.StructChild);

            // Should be a mock
            Mock.Get(i1).Should().NotBeNull();
            i1.IsMockType().Should().BeTrue();
            sut.Mock.Should().BeSameAs(Mock.Get(i1));

            return Task.CompletedTask;
        }

        [Theory, AutoMoqData]
        public Task FixtureSetup_Default_ShouldReturnAutoGeneratedValues(IFixture fixture)
        {
            // Arrange
            var simpleChild = new SimpleChildFixture(fixture).Object;
            var complexChildFixture = new ComplexChildFixture(fixture);
            var complexChild = complexChildFixture.Object;

            // Act
            // Note: All instances here should be same,
            // because we override with our own fixture
            var sut = new ComplexParentFixture(fixture);
            var i1 = sut.Object;
            var i2 = fixture.Create<ComplexParent>();
            i1.Should().BeSameAs(i2);

            // Assert
            var instances = new List<ComplexParent>
            {
                i1,
                i2,
                new ComplexParentFixture(fixture).Object
            };
            simpleChild.Should().NotBeNull();
            complexChild.Should().NotBeNull();
            foreach (var instance in instances)
            {
                instance.Should().NotBeNull();
                instance.IsMockType().Should().BeTrue();
                instance.Name.Should().NotBeNullOrEmpty();
                instance.Number.Should().BeGreaterThan(0);
                instance.ConcurrencyStamp.ToString().Should().NotBeNullOrEmpty();

                // ComplexChild is injected
                instance.ComplexChild.Should().NotBeNull();
                instance.ComplexChild.IsMockType().Should().BeTrue();
                instance.ComplexChild.Should().BeSameAs(complexChild); // Same instance for created fixture

                // SimpleChild is injected
                instance.SimpleChild.Should().NotBeNull();
                instance.SimpleChild!.IsMockType().Should().BeTrue();
                instance.SimpleChild.Should().BeSameAs(simpleChild);

                // StructChild is injected
                instance.StructChild.Should().NotBeNull();
                instance.StructChild.Should().BeEquivalentTo(ComplexParentFixture.StructChild);
            }

            return Task.CompletedTask;
        }

        [Theory, AutoMoqData]
        public Task FixtureSetup_DI_ShouldReturnDifferentSetupValues(
            IFixture fixture,
            [Frozen] SimpleChild simpleChild,
            [Frozen] ComplexChild complexChild,
            [Frozen] StructChild structChild,
            ComplexParent sut
        )
        {
            // Act
            // Note: All instances here should be different,
            // because AutoFixture will create an instance before entering this function
            var i1 = sut;
            var i2 = fixture.Create<ComplexParent>();
            i1.Should().NotBeEquivalentTo(i2);

            // Assert
            var instances = new List<ComplexParent>
            {
                i1,
                i2,
                new ComplexParentFixture(fixture, options => options
                    .Setup(_ => _.StructChild, structChild)).Object
            };

            simpleChild.Should().NotBeNull();
            complexChild.Should().NotBeNull();
            structChild.Should().NotBeNull();
            foreach (var instance in instances)
            {
                instance.Should().NotBeNull();
                instance.IsMockType().Should().BeTrue();
                instance.Name.Should().NotBeNullOrEmpty();
                instance.Number.Should().BeGreaterThan(0);
                instance.ConcurrencyStamp.ToString().Should().NotBeNullOrEmpty();

                // ComplexChild is injected
                instance.ComplexChild.Should().NotBeNull();
                instance.ComplexChild.IsMockType().Should().BeTrue();
                instance.ComplexChild.Should().BeSameAs(complexChild); // Same instance for created fixture

                // SimpleChild is injected
                instance.SimpleChild.Should().NotBeNull();
                instance.SimpleChild!.IsMockType().Should().BeTrue();
                instance.SimpleChild.Should().BeSameAs(simpleChild); // Same instance for created fixture

                // StructChild has its own setup in fixture
                instance.StructChild.Should().NotBeNull();
                instance.StructChild.Should().BeEquivalentTo(structChild);
            }

            return Task.CompletedTask;
        }

        [Theory, AutoMoqData]
        public Task FixtureSetup_InjectItem_ShouldReturnInjectedObject(IFixture fixture)
        {
            // Arrange
            var complexChild = new ComplexChildFixture(fixture).Object;
            var injected = new Mock<ComplexParent>(complexChild) { CallBase = true, DefaultValue = DefaultValue.Mock };
            injected.SetupProperty(_ => _.Name, "OverridenText");
            injected.SetupProperty(_ => _.Number, 111);
            injected.SetupProperty(_ => _.ConcurrencyStamp, new Guid("6f55a677-c447-45f0-8e71-95c7b73fa889"));

            // Act
            var sut = new ComplexParentFixture(fixture, injected.Object);
            var i1 = sut.Object;
            var i2 = fixture.Create<ComplexParent>();
            i1.Should().BeSameAs(i2);

            // Assert
            var instances = new List<ComplexParent> { i1, i2 };
            foreach (var instance in instances)
            {
                instance.Should().NotBeNull();
                instance.IsMockType().Should().BeTrue();
                instance.Should().BeSameAs(injected.Object);
                instance.Name.Should().Be("OverridenText");
                instance.Number.Should().Be(111);
                instance.ConcurrencyStamp.ToString().Should().Be("6f55a677-c447-45f0-8e71-95c7b73fa889");

                // ComplexChild is injected via constructor, should be the same
                instance.ComplexChild.Should().NotBeNull();
                instance.ComplexChild.IsMockType().Should().BeTrue();
                instance.ComplexChild.Should().BeSameAs(complexChild);

                // SimpleChild is 'null' in injected, should be 'null'
                instance.SimpleChild.Should().BeNull();

                // StructChild is 'default' in injected, should be 'default'
                instance.StructChild.Should().NotBeNull();
                instance.StructChild.Should().Be(default(StructChild));
            }

            return Task.CompletedTask;
        }

        [Theory, AutoMoqData]
        public Task FixtureSetup_InjectOptions_ShouldReturnInjectedValues(IFixture fixture)
        {
            // Arrange
            var complexChild = new ComplexChildFixture(fixture).Object;

            // Act
            var sut = new ComplexParentFixture(fixture, options => options
                .Setup(_ => _.ComplexChild, complexChild)
                .Setup(_ => _.Name, "OverridenText")
                .Setup(_ => _.Number, 111)
                .Setup(_ => _.ConcurrencyStamp, new Guid("6f55a677-c447-45f0-8e71-95c7b73fa889"))
            );
            var i1 = sut.Object;
            var i2 = fixture.Create<ComplexParent>();
            i1.Should().BeSameAs(i2);

            // Assert
            var instances = new List<ComplexParent> { i1, i2 };
            foreach (var instance in instances)
            {
                instance.Should().NotBeNull();
                instance.IsMockType().Should().BeTrue();
                instance.Name.Should().Be("OverridenText");
                instance.Number.Should().Be(111);
                instance.ConcurrencyStamp.ToString().Should().Be("6f55a677-c447-45f0-8e71-95c7b73fa889");

                // ComplexChild is injected via constructor, should be the same
                instance.ComplexChild.Should().NotBeNull();
                instance.ComplexChild.IsMockType().Should().BeTrue();
                instance.ComplexChild.Should().BeSameAs(complexChild);

                // SimpleChild is auto generated by AutoFixture
                instance.SimpleChild.Should().NotBeNull();

                // StructChild is auto generated by AutoFixture
                instance.StructChild.Should().NotBeNull();
                instance.StructChild.Should().NotBeEquivalentTo(ComplexParentFixture.StructChild);
            }

            return Task.CompletedTask;
        }
    }
}